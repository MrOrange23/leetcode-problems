package my.playground.leetcode._924_minimize_malware_spread;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * 367 ms
 */
public class Solution {

  public int minMalwareSpread(int[][] graph, int[] initial) {
    int minInfectedAmount = Integer.MAX_VALUE;
    int minNodeIndex = Integer.MAX_VALUE;
    for (int i = 0; i < initial.length; i++) {
      List<Integer> initialList = toList(initial);

      int nodeIndex = initialList.get(i);
      initialList.remove(i);

      Network n = new Network(graph, initialList);
      int totalIntected = n.totalInfected();

      if (minInfectedAmount > totalIntected) {
        minInfectedAmount = totalIntected;
        minNodeIndex = nodeIndex;
      }
    }

    return minNodeIndex;
  }

  static List<Integer> toList(int[] array) {
    List<Integer> list = new ArrayList<>(array.length);
    for (int i = 0; i < array.length; i++) {
      list.add(array[i]);
    }
    Collections.sort(list);
    return list;
  }

  static class Network extends HashMap<Integer, Node> {

    Set<Integer> initialInfected;

    void init(List<Integer> initial) {
      initialInfected = new HashSet<>(initial.size());
      initialInfected.addAll(initial);
    }

    Network(int[][] graph, List<Integer> initial) {
      init(initial);

      for (int i = 0; i < graph.length; i++) {
        for (int j = 0; j < graph.length; j++) {
          Node node = getOrCreate(i);
          if (i != j && graph[i][j] == 1) {
            node.addPeer(getOrCreate(j));
          }
        }
      }
    }

    Node getOrCreate(int index) {
      Node node = this.get(index);
      if (node == null) {
        node = new Node(index, isInitiallyInfected(index));
        this.put(index, node);
      }
      return node;
    }

    boolean isInitiallyInfected(int index) {
      return initialInfected.contains(index);
    }

    int totalInfected() {
      int total = 0;
      for (Entry<Integer, Node> entry : this.entrySet()) {
        if (entry.getValue().infected) {
          total++;
        }
      }
      return total;
    }

  }

  static class Node {
    int index;
    boolean infected;
    Set<Node> peers = new HashSet<>();

    Node(int index, boolean infected) {
      this.index = index;
      this.infected = infected;
    }

    void doInfect() {
      this.infected = true;
      for (Node peer : peers) {
        if (!peer.infected)
          peer.doInfect();
      }
    }

    void addPeer(Node newPeer) {
      if (infected && !newPeer.infected) {
        newPeer.doInfect();
      }

      if (newPeer.infected && !infected) {
        doInfect();
      }

      peers.add(newPeer);
    }

    @Override
    public int hashCode() {
      return index;
    }

    @Override
    public boolean equals(Object obj) {
      return obj instanceof Node
          && ((Node) obj).index == this.index;
    }
  }

}
