package my.playground.leetcode._924_minimize_malware_spread;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * 51 tests ~35ms
 * 51 tests ~24ms
 * 51 tests ~33ms
 */
public class Solution2 {

  private static List<Set<Integer>> network;

  public int minMalwareSpread(int[][] graph, int[] initial) {
    network = new Network(graph);

    Arrays.sort(initial);

    int totalInfected = Integer.MIN_VALUE;
    int minNodeIndex = 0;

    for (Set<Integer> subnet : network) {
      for (int index : initial) {
        if (subnet.contains(index) && totalInfected < subnet.size()) {
          totalInfected = subnet.size();
          minNodeIndex = index;
        }
      }
    }

    return minNodeIndex;
  }

  public static class Network extends ArrayList<Set<Integer>> {

    Network(int[][] graph) {
      Set<Integer> processed = new HashSet<>(graph.length);

      for (int i = 0; i < graph.length; i++) {
        if (processed.contains(i)) continue;

        Set<Integer> subnet = new HashSet<>(graph.length);
        buildSubnet(i, graph, subnet, processed);
        this.add(subnet);
      }
    }

    private void buildSubnet(int index, int[][] graph, Set<Integer> newSubnet,
        Set<Integer> processed) {
      int[] node = graph[index];

      for (int j = 0; j < node.length; j++) {
        if (node[j] == 1 && !processed.contains(j)) {
          newSubnet.add(j);
          processed.add(j);

          buildSubnet(j, graph, newSubnet, processed);
        }
      }
    }

  }


}
